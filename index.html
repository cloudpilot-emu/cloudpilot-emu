<html>

<head>
    <meta name="viewport" content="width=520,user-scalable=no" />
    <meta name="apple-mobile-web-app-capable" content="yes" />

    <title>Cloudpilot</title>
    <style>
        html {
            padding: 0;
            margin: 0;
        }

        body {
            min-width: 480px;
            margin: 0;
            padding: 8px 16px;
        }

        #rom-name {
            margin-bottom: 1rem;
        }

        #control-buttons {
            margin-bottom: 0.5em;
        }

        #control-username {
            margin-bottom: 0.5em;
        }

        #canvas {
            width: 480px;
            height: 660px;
            display: block;
            margin-top: 1rem;
            border: 1px solid black;
        }

        #canvas:focus {
            outline: none;
            border: 1px solid black;
        }

        #image-upload,
        #file-upload {
            display: none;
        }

        #reset-control {
            margin-top: 1em;
        }

        #console {
            margin-top: 1rem;
            width: 100%;
            height: 15em;
            overflow-y: scroll;
            -webkit-overflow-scrolling: touch;
            word-wrap: break-word;
            white-space: pre-line;
        }

        #buttons {
            display: flex;
            flex-direction: row;
        }

        .palm-button {
            display: block;
            height: 3em;
            width: 52px;
            height: 52px;
            margin: 10px 0 0 0;
            padding: 0;
            border: none;
            display: inline-block;
            touch-action: manipulation;
            background: #bbb;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: nones;
        }

        .palm-button:not(:last-child) {
            margin-right: 9px;
        }

        .palm-button:hover,
        .palm-button:focus {
            border: none;
            outline: none;
        }

        #snapshot-indicator {
            margin-top: 1em;
        }
    </style>
</head>

<body>
    <div id="rom-name">&nbsp;</div>
    <div id="control-buttons">
        <label>
            <input type="file" id="image-upload"></input>
            <button type="button" id="image-upload-button">Load ROM or Image</button>
        </label>
        <label>
            <button type="button" disabled id="image-download-button">Save Image</button>
        </label>
        <label>
            <input type="file" id="file-upload" multiple></input>
            <button type="button" disabled id="file-upload-button">Install file</button>
        </label>
    </div>
    <div id="control-username">
        <label>
            Username:
            <input type="text" id="input-username" maxlength="30"></label>
        </label>
    </div>
    <div id="control-reset">
        <select name="reset-type" id="reset-type-select">
            <option value="soft" selected>Soft reset</option>
            <option value="noext">Reset w/o extensions</option>
            <option value="hard">Hard reset</option>
        </select>
        <button id="reset-button" type="button">Reset!</button>
    </div>

    <div id="snapshot-indicator">No snapshot saved yet</div>
    <canvas id="canvas" width="160" height="220" tabindex="1"></canvas>

    <div id="buttons">
        <button class="palm-button" type="button" data-id="app1">Cal</button>
        <button class="palm-button" type="button" data-id="app2">Phone</button>
        <button class="palm-button" type="button" data-id="app3">Todo</button>
        <button class="palm-button" type="button" data-id="app4">Notes</button>
        <button class="palm-button" type="button" data-id="rockerUp">Up</button>
        <button class="palm-button" type="button" data-id="rockerDown">Down</button>
        <button class="palm-button" type="button" data-id="cradle">Sync</button>
        <button class="palm-button" type="button" data-id="power">Power</button>
    </div>

    <pre id="console"></pre>

    <script src="src/cloudpilot.js"></script>
    <script>
        (async function () {
            const DB_NAME = 'cloudpilot-sdl';
            const OBJECT_STORE_KVS = 'kvs';
            const OBJECT_STORE_MEMORY = 'memory';
            const OBJECT_STORE_STATE = 'state';

            const KEY_ROM_NAME = 'romName';
            const KEY_ROM_IMAGE = 'romImage';
            const KEY_ROM_MEMORY_SIZE = 'memorySize';

            const DB_GRACE_TIME_MS = 3000;
            const IMAGE_MAGIC = 0x20150103 | 0;
            const IMAGE_VERSION = 0x80000001 | 0;
            const UPDATE_MEMORY_IMAGE_INTERVAL = 1000;

            const imageUploadButton = document.getElementById('image-upload-button');
            const imageUpload = document.getElementById('image-upload');

            const fileUploadButton = document.getElementById('file-upload-button');
            const fileUpload = document.getElementById('file-upload');
            const imageDownloadButton = document.getElementById('image-download-button');
            const usernameInput = document.getElementById('input-username');
            const resetTypeSelect = document.getElementById('reset-type-select');
            const resetButton = document.getElementById('reset-button');

            const romName = document.getElementById('rom-name');
            const consoleElt = document.getElementById('console');
            const canvasElt = document.getElementById('canvas');

            const snapshotIndicator = document.getElementById('snapshot-indicator');

            const KEY_PAGE_LOCK = "cloudpilot-sdl-lock";
            const PAGE_LOCK_ERROR = new Error('page opened in another tab');

            let kvs;
            let memoryPersistence;
            let db;

            /**
             * No more memory dump transactions on other tabs that are already running will start
             * beyond this point. Per IDB spec, any dump transactions that have already started will
             * complete before we access the memory store for either writing or reading memory.
             *
             * This ensures consistency by making sure that
             *
             * 1. No existing tab will save data after we read the memory image
             *    (relevant if we started with an existing image).
             *
             * 2. No existing tab will save data after we write for the memory image for the first
             *    time (relevant if we started with a fresh rom).
             */

            // ====================================================================================
            const pageLockValue = Date.now().toString() + Math.random().toString();
            localStorage.setItem(KEY_PAGE_LOCK, pageLockValue);
            // ====================================================================================

            // ####################################################################################
            // Helpers
            // ####################################################################################

            function pageLockLost() {
                return localStorage.getItem(KEY_PAGE_LOCK) !== pageLockValue;
            }

            function escape(text) {
                const node = document.createElement('div');

                node.innerText = text;

                return node.innerHTML;
            }

            function appendLog(msg) {
                consoleElt.innerHTML += (escape(msg) + '<br/>');
                consoleElt.scrollTop = consoleElt.scrollHeight;
            }

            function errorFromEvent(evt) {
                let msg = 'unknown error';

                let error = evt.error;
                if (!error && evt.target) error = evt.target.error;

                if (error && error.message) {
                    msg = error.message;
                } else if (event.message) {
                    msg = event.message;
                }

                return new Error(msg);
            }

            function write32LE(value, target, i) {
                target[i] = value & 0xff;
                target[i + 1] = (value >>> 8) & 0xff;
                target[i + 2] = (value >>> 16) & 0xff;
                target[i + 3] = (value >>> 24) & 0xff;
            }

            function read32LE(target, i) {
                return target[i] | (target[i + 1] << 8) | (target[i + 2] << 16) | (target[i + 3] << 24);
            }

            async function setupDb() {
                db = await new Promise((resolve, reject) => {
                    const request = window.indexedDB.open(DB_NAME, 2);

                    request.onerror = e => reject(new Error('failed to open DB'));
                    request.onsuccess = () => resolve(request.result);

                    request.onupgradeneeded = (event) => {
                        if (event.oldVersion < 1) {
                            request.result.createObjectStore(OBJECT_STORE_KVS);
                            request.result.createObjectStore(OBJECT_STORE_MEMORY);
                        }

                        if (event.oldVersion < 2) {
                            request.result.createObjectStore(OBJECT_STORE_STATE);
                        }
                    }
                });

                db.onerror = evt => appendLog(`indexeddb error: ${errorFromEvent(evt)}`);

                kvs = new Kvs(db);
            }


            // ####################################################################################
            // KVS
            // ####################################################################################

            class Kvs {
                constructor(db) {
                    this.db = db;
                }

                get(key) {
                    // Using a RW transaction here grants us an exlusive lock
                    const transaction = this.db.transaction(OBJECT_STORE_KVS, 'readwrite');
                    const request = transaction.objectStore(OBJECT_STORE_KVS).get(key);

                    return new Promise((resolve, reject) => {
                        request.onerror = () => reject(new Error('error reading from KVS'));
                        request.onsuccess = () => resolve(request.result);
                    })
                }

                async put(key, value) {
                    const transaction = this.db.transaction(OBJECT_STORE_KVS, 'readwrite');
                    await this.waitForTransactionLock(transaction);

                    const request = transaction.objectStore(OBJECT_STORE_KVS).put(value, key);

                    return new Promise((resolve, reject) => {
                        transaction.onerror = () => reject(new Error('error writing to KVS'));
                        transaction.oncomplete = () => resolve();
                    });
                }

                async delete(key) {
                    const transaction = this.db.transaction(OBJECT_STORE_KVS, 'readwrite');
                    await this.waitForTransactionLock(transaction);

                    const request = transaction.objectStore(OBJECT_STORE_KVS).delete(key);

                    return new Promise((resolve, reject) => {
                        transaction.onerror = () => reject(new Error('error deleting from KVS'));
                        transaction.oncomplete = () => resolve();
                    });
                }

                async waitForTransactionLock(transaction) {
                    // Make sure that the transaction has started by performing a dummy read on
                    // the store.

                    await new Promise((resolve, reject) => {
                        const lock = transaction.objectStore(OBJECT_STORE_KVS).get(-1);

                        lock.onsuccess = resolve;
                        lock.onerror = evt => reject(errorFromEvent(evt));
                    });

                    // On the running transaction, check whether another tab has claimed the storage.
                    if (pageLockLost()) {
                        throw PAGE_LOCK_ERROR;
                    }
                }
            }


            // ####################################################################################
            // Memory Persistence
            // ####################################################################################

            class MemoryPersistence {
                constructor(db, size, module) {
                    this.db = db;
                    this.size = size;
                    this.module = module;
                    this.lastUpdateAt = 0;
                    this.active = false;

                    const pageCount = (size >>> 10) + (size % 1024 ? 1 : 0);
                    this.dirtyPages = new Uint8Array((pageCount >>> 3) + (pageCount % 8 ? 1 : 0));

                    this.pages = new Array(pageCount);
                    for (let i = 0; i < pageCount; i++) this.pages[i] = new Int8Array(1024);

                    this.transaction = null;

                    this.dirtyPagesPtr = module.cwrap('dirtyPagesPtr', 'number', []);
                    this.memoryPtr = module.cwrap('memoryPtr', 'number', []);
                    this.uiInitialized = module.cwrap('uiInitialized', 'number', []);
                    this.saveStateNative = module.cwrap('saveState', 'number', []);
                    this.getSavestateSize = module.cwrap('getSavestateSize', 'number', []);
                    this.getSavestatePtr = module.cwrap('getSavestatePtr', 'number', []);

                    this.intervalHandle = null;
                    this.consecutiveErrorCount = 0;
                }

                start() {
                    this.active = true;
                }

                onCycle() {
                    if (!this.active) return;

                    const now = performance.now();

                    if ((now - this.lastUpdateAt) >= UPDATE_MEMORY_IMAGE_INTERVAL) {
                        this.snapshotTask();
                        this.lastUpdateAt = now;
                    }
                }

                async snapshotTask() {
                    if (this.transaction || !this.uiInitialized()) return;

                    try {
                        if (await this.snapshot()) {
                            const now = new Date();
                            snapshotIndicator.innerText = `last snapshot saved on ${now.toLocaleDateString()} ${now.toLocaleTimeString()}`;

                            this.consecutiveErrorCount = 0;

                            this.transaction = null;
                        }
                    } catch (e) {
                        appendLog(`failed to save memory snapshot: ${(e && e.message) ? e.message : 'failed'}`);

                        if (e === PAGE_LOCK_ERROR) {
                            this.stop();

                            alert('Page opened in another tab. State in this tab will not be saved anymore.');
                        } else if (++this.consecutiveErrorCount > 3) {
                            this.recover();
                        }

                        snapshotIndicator.style.color = 'red';

                        this.transaction = null;
                    }
                }

                async waitForTransactionLock(transaction) {
                    // Make sure that the transaction has started by performing a dummy read on
                    // the store.

                    await new Promise((resolve, reject) => {
                        const lock = transaction.objectStore(OBJECT_STORE_MEMORY).get(-1);

                        lock.onsuccess = resolve;
                        lock.onerror = evt => reject(errorFromEvent(evt));
                    });

                    // On the running transaction, check whether another tab has claimed the storage.
                    if (pageLockLost()) {
                        throw PAGE_LOCK_ERROR;
                    }
                }

                async snapshot() {
                    if (this.transaction) return false;

                    const transaction = this.db.transaction([OBJECT_STORE_MEMORY, OBJECT_STORE_STATE], 'readwrite');
                    this.transaction = transaction;

                    await this.waitForTransactionLock(transaction);

                    // From now on, we can be sure that no other tab has interacted with the storage
                    // before this transaction completes.

                    this.saveDirtyPages(transaction);
                    this.saveState(transaction);

                    await new Promise((resolve, reject) => {
                        const watchdog = setTimeout(() => {
                            reject(new Error('transaction timed out'));

                            transaction.abort();
                        }, DB_GRACE_TIME_MS);

                        transaction.oncomplete = () => {
                            resolve();

                            clearTimeout(watchdog);
                            this.dirtyPages.fill(0);
                        };

                        transaction.onerror = evt => {
                            reject(errorFromEvent(evt));

                            clearTimeout(watchdog);
                        };

                        transaction.onabort = () => {
                            reject(new Error('transaction aborted'));

                            clearTimeout(watchdog);
                        };
                    });

                    return true;
                }

                saveState(transaction) {
                    const objectStore = transaction.objectStore(OBJECT_STORE_STATE);

                    const savestate = this.getSavestate();
                    if (!savestate) {
                        objectStore.clear();
                        return;
                    }

                    const copy = new Uint8Array(savestate.length);
                    copy.set(savestate);

                    objectStore.put(copy, 0);
                }

                saveDirtyPages(transaction, memory, dirtyPages) {
                    let iPage = 0;
                    dirtyPages = dirtyPages || this.getDirtyPages();
                    memory = memory || this.getMemory();
                    const objectStore = transaction.objectStore(OBJECT_STORE_MEMORY);

                    for (let i = 0; i < dirtyPages.length; i++) {
                        this.dirtyPages[i] |= dirtyPages[i];
                        dirtyPages[i] = 0;

                        if (this.dirtyPages[i] == 0) {
                            iPage += 8;
                            continue;
                        }

                        for (let j = 0; j < 8; j++) {
                            if (this.dirtyPages[i] & (1 << j)) {
                                this.pages[iPage].set(memory.subarray(iPage * 1024, (iPage + 1) * 1024));

                                objectStore.put(this.pages[iPage], iPage);
                            }

                            iPage++;
                        }
                    }
                }

                stop() {
                    if (this.transaction) {
                        try {
                            this.transaction.abort();
                        } catch (e) { }

                        this.transaction = null;
                    }

                    this.active = false;
                }

                async load() {
                    const image = new Int8Array(this.size);

                    // Use 'readwrite' in order to ensure that any write transaction from another tab
                    // will complete before we start reading.
                    const transaction = this.db.transaction([OBJECT_STORE_MEMORY, OBJECT_STORE_STATE], 'readwrite');

                    const savestate = await new Promise((resolve, reject) => {
                        const request = transaction.objectStore(OBJECT_STORE_STATE).get(0);

                        request.onerror = () => reject(new Error('error reading from state store'));
                        request.onsuccess = () => resolve(request.result);
                    });

                    const memoryImage = await new Promise((resolve, reject) => {
                        const request = transaction.objectStore(OBJECT_STORE_MEMORY).openCursor();

                        request.onsuccess = () => {
                            const cursor = request.result;

                            if (!cursor) return resolve(image);

                            const page = cursor.value;
                            const iPage = cursor.key;

                            if (iPage * 1024 < this.size) {
                                image.subarray(iPage * 1024, Math.min((iPage + 1) * 1024, this.size)).set(page);
                            }

                            cursor.continue();
                        }

                        request.onerror = () => reject(new Error("failed to load memory image"));
                    });

                    return [memoryImage, savestate];
                }

                async reset() {
                    if (this.intervalHandle) {
                        throw new Error("reset called on running MemoryPersistence instance");
                    }

                    const transaction = this.db.transaction([OBJECT_STORE_MEMORY, OBJECT_STORE_STATE], 'readwrite');

                    await this.waitForTransactionLock(transaction);

                    transaction.objectStore(OBJECT_STORE_MEMORY).clear();
                    transaction.objectStore(OBJECT_STORE_STATE).clear();

                    return new Promise((resolve, reject) => {
                        transaction.oncomplete = () => resolve();
                        transaction.onerror = () => reject(new Error('failed to clear stored state'));
                    });
                }

                async recover() {
                    appendLog('too many indexeddb errors, starting recovery');

                    this.stop();

                    try {
                        db.close();
                    } catch (e) { }

                    try {
                        await new Promise(r => setTimeout(r, DB_GRACE_TIME_MS));
                        await setupDb();

                        this.db = db;
                        this.start();

                        appendLog('indexeddb recovery complete');
                    } catch (e) {
                        appendLog(`indexeddb recovery failed: ${e.message || 'unknown error'}`);
                    }
                }

                getDirtyPages() {
                    const dirtyPagesPtr = this.dirtyPagesPtr();

                    return this.module.HEAP8.subarray(dirtyPagesPtr, dirtyPagesPtr + this.dirtyPages.length);
                }

                getMemory() {
                    const memoryPtr = this.memoryPtr();

                    return this.module.HEAP8.subarray(memoryPtr, memoryPtr + this.size);
                }

                getSavestate() {
                    if (!this.saveStateNative()) return null;

                    const savestatePtr = this.getSavestatePtr();
                    return this.module.HEAP8.subarray(savestatePtr, savestatePtr + this.getSavestateSize());
                }

                async saveMemoryImageAndState(buffer, savestate) {
                    if (buffer.length !== this.size) throw new Error('size mismatch');

                    const isEmpty = buf => {
                        for (let i = 0; i < buf.length; i++) if (buf[i] !== 0) return false;
                        return true;
                    }

                    const dirtyPages = new Uint8Array(this.dirtyPages.length);

                    for (let i = 0; i < dirtyPages.length; i++) {
                        dirtyPages[i] = 0;

                        for (let j = 0; j < 8; j++) {
                            const offset = (i * 8 + j) * 1024;
                            dirtyPages[i] |= ((isEmpty(buffer.subarray(offset, offset + 1024)) ? 0 : 1) << j);
                        }
                    }

                    const transaction = this.db.transaction([OBJECT_STORE_MEMORY, OBJECT_STORE_STATE], 'readwrite');

                    await this.waitForTransactionLock(transaction);

                    this.dirtyPages.fill(0)
                    transaction.objectStore(OBJECT_STORE_MEMORY).clear();
                    this.saveDirtyPages(transaction, buffer, dirtyPages);

                    if (savestate.length > 0) {
                        transaction.objectStore(OBJECT_STORE_STATE).put(savestate, 0);
                    } else {
                        transaction.objectStore(OBJECT_STORE_STATE).clear();
                    }

                    return new Promise((resolve, reject) => {
                        transaction.oncomplete = () => resolve();
                        transaction.onerror = () => reject(new Error('failed to clear stored memory'));
                    });
                }
            }

            // ####################################################################################
            // Image file handling
            // ####################################################################################

            function imageFileName(romName) {
                const now = new Date();

                const year = now.getFullYear();
                const month = (now.getMonth() + 1).toString().padStart(2, '0');
                const day = now.getDate().toString().padStart(2, '0');
                const hour = now.getHours().toString().padStart(2, '0');
                const minute = now.getMinutes().toString().padStart(2, '0');
                const second = now.getSeconds().toString().padStart(2, '0');

                return `${romName.replace(/\.[^\.]*$/, '')}_${year}${month}${day}-${hour}${minute}${second}.bin`;
            }

            async function saveImage(module) {
                const romName = await kvs.get(KEY_ROM_NAME);
                const metadata = new TextEncoder().encode(JSON.stringify({ romName }));
                const deviceId = new TextEncoder().encode(module.ccall('getDeviceId', 'string', []));

                const romPtr = module.ccall('getRomPtr', 'number', []);
                const romSize = module.ccall('getRomSize', 'number', []);
                const rom = module.HEAP8.subarray(romPtr, romPtr + romSize);

                const memoryPtr = module.ccall('memoryPtr', 'number', []);
                const memorySize = module.ccall('memorySize', 'number', [], []);
                const memory = module.HEAP8.subarray(memoryPtr, memoryPtr + memorySize);

                let savestate = new Uint8Array(0);
                if (module.ccall('saveState', 'number', [])) {
                    const savestatePtr = module.ccall('getSavestatePtr', 'number', []);
                    const savestateSize = module.ccall('getSavestateSize', 'number', []);

                    savestate = module.HEAP8.subarray(savestatePtr, savestatePtr + savestateSize);
                }

                const serializedImage = new Uint8Array(
                    28 + deviceId.length + metadata.length + rom.length + memory.length + savestate.length
                );

                write32LE(IMAGE_MAGIC, serializedImage, 0);
                write32LE(IMAGE_VERSION, serializedImage, 4);
                write32LE(deviceId.length, serializedImage, 8);
                write32LE(metadata.length, serializedImage, 12);
                write32LE(rom.length, serializedImage, 16);
                write32LE(memory.length, serializedImage, 20);
                write32LE(savestate.length, serializedImage, 24);

                serializedImage.set(deviceId, 28);
                serializedImage.set(metadata, 28 + deviceId.length);
                serializedImage.set(rom, 28 + deviceId.length + metadata.length);
                serializedImage.set(memory, 28 + deviceId.length + metadata.length + rom.length);
                serializedImage.set(savestate, 28 + deviceId.length + metadata.length + rom.length + memory.length);

                const file = new Blob([serializedImage], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(file);

                const a = document.createElement('a');
                a.href = url;
                a.download = imageFileName(romName);
                a.click();
            }

            function loadImage(buffer) {
                if (buffer.length < 16) return undefined;
                if (read32LE(buffer, 0) !== IMAGE_MAGIC) return undefined;
                if ((read32LE(buffer, 4) & 0x80000000) === 0) return loadLegacyImage(buffer);
                if (read32LE(buffer, 4) !== IMAGE_VERSION) return undefined;
                if (buffer.length < 28) return undefined;

                const deviceIdSize = read32LE(buffer, 8);
                const metadataSize = read32LE(buffer, 12);
                const romSize = read32LE(buffer, 16);
                const memorySize = read32LE(buffer, 20);
                const savestateSize = read32LE(buffer, 24);

                if ((28 + deviceIdSize + metadataSize + romSize + memorySize + savestateSize) !== buffer.length)
                    return undefined;

                let romName = "[unknown]";
                try {
                    const metadata = JSON.parse(new TextDecoder().decode(buffer.subarray(28 + deviceIdSize, 28 + deviceIdSize + metadataSize)));
                    romName = metadata.romName ? metadata.romName : romName;
                } catch (e) { }

                return {
                    romName,
                    rom: buffer.subarray(28 + deviceIdSize + metadataSize, 28 + deviceIdSize + metadataSize + romSize),
                    memory: buffer.subarray(28 + deviceIdSize + metadataSize + romSize, 28 + deviceIdSize + metadataSize + romSize + memorySize),
                    savestate: buffer.subarray(28 + deviceIdSize + metadataSize + romSize + memorySize)
                }
            }

            function loadLegacyImage(buffer) {
                const romNameSize = read32LE(buffer, 4);
                const romSize = read32LE(buffer, 8);
                const memorySize = read32LE(buffer, 12);

                if ((romNameSize + romSize + memorySize + 16) !== buffer.length) return undefined;

                return {
                    romName: new TextDecoder().decode(buffer.subarray(16, 16 + romNameSize)),
                    rom: buffer.subarray(16 + romNameSize, 16 + romNameSize + romSize),
                    memory: buffer.subarray(16 + romNameSize + romSize),
                    savestate: new Uint8Array(0)
                };
            }

            let setUsernameTimeoutHandle = null;

            // ####################################################################################
            // Session ready
            // ####################################################################################

            async function onSessionReady() {
                const nativeButtonDown = this.cwrap('buttonDown', null, ['string']);
                const nativeButtonUp = this.cwrap('buttonUp', null, ['string']);
                const nativeSetUserName = this.cwrap('setUserName', null, ['string']);
                const nativeReset = this.cwrap('reset', null, ['string']);

                let currentButtons = new Set();

                Array.from(document.querySelectorAll('.palm-button'))
                    .forEach(btn =>
                        ['mousedown', 'touchstart'].forEach(
                            event => btn.addEventListener(event, evt => {
                                currentButtons.add(evt.target);

                                nativeButtonDown(evt.target.dataset.id);

                                evt.preventDefault();
                            })));


                ['mouseup', 'touchend'].forEach(
                    event => window.addEventListener(event, evt => {
                        if (currentButtons.size > 0) {
                            currentButtons.forEach(btn => nativeButtonUp(btn.dataset.id));

                            currentButtons.clear();

                            evt.preventDefault();
                        }
                    }));


                usernameInput.addEventListener('change', e => {
                    if (setUsernameTimeoutHandle !== null) clearTimeout(setUsernameTimeoutHandle);

                    setUsernameTimeoutHandle = setTimeout(() => {
                        setUsernameTimeoutHandle = null;

                        nativeSetUserName(e.target.value);
                    })
                })

                // Work around missing SDL_TEXTINPUT for option-X key combos on MacOS
                window.addEventListener(
                    'keydown',
                    e => {
                        if (e.altKey && e.key.length === 1) {
                            e.stopPropagation();
                            window.dispatchEvent(new KeyboardEvent('keydown', { altKey: false, key: e.key }));
                        }
                    },
                    true
                );

                // Hack to enable focus on the canvas element
                window.addEventListener('mousedown',
                    e => {
                        if (e.target === canvasElt) {
                            const scrollX = window.scrollX, scrollY = window.scrollY;

                            canvasElt.focus({ preventScroll: true });

                            setTimeout(() => window.scrollTo(scrollX, scrollY), 0);
                        }
                    }, true);

                const memorySize = this.ccall('memorySize', 'number', [], []);

                resetButton.addEventListener('click', () => nativeReset(resetTypeSelect.value));
                imageDownloadButton.addEventListener('click', () => saveImage(this));
                fileUploadButton.disabled = false;
                imageDownloadButton.disabled = false;

                if (!memoryPersistence) {
                    memoryPersistence = new MemoryPersistence(db, memorySize, this);
                }
                memoryPersistence.start();

                usernameInput.value = module.ccall('getUserName', 'string', []);

                await kvs.put(KEY_ROM_MEMORY_SIZE, memorySize);
            }

            // ####################################################################################
            // Main (after WASM load)
            // ####################################################################################

            async function main(module) {
                async function launch() {
                    romName.innerText = `ROM: ${await (kvs.get(KEY_ROM_NAME))}`;

                    module.FS.writeFile('/palm.rom', await kvs.get(KEY_ROM_IMAGE));
                    const args = ['/palm.rom'];

                    if (memoryPersistence) {
                        const [memoryImage, savestate] = await memoryPersistence.load()

                        module.FS.writeFile('/memory.bin', memoryImage);
                        args.push('/memory.bin');

                        if (savestate) {
                            module.FS.writeFile('/savestate.bin', savestate);
                            args.push('/savestate.bin');
                        }
                    }

                    module.callMain(args);
                }

                async function processUpload(file) {
                    return new Promise((resolve, reject) => {
                        const reader = new FileReader();

                        reader.addEventListener('load', () => resolve(new Uint8Array(reader.result)));
                        reader.addEventListener('error', () => reject(reader.error));

                        reader.readAsArrayBuffer(file);
                    });
                }

                async function tryHandleImage(buffer) {
                    const loaded = loadImage(buffer);
                    if (!loaded) return false;

                    const { romName, rom, memory, savestate } = loaded;

                    await kvs.delete(KEY_ROM_IMAGE);
                    await kvs.delete(KEY_ROM_NAME);
                    await kvs.delete(KEY_ROM_MEMORY_SIZE);

                    if (memoryPersistence) {
                        memoryPersistence.stop();
                        await memoryPersistence.reset();
                    }

                    memoryPersistence = new MemoryPersistence(db, memory.length, module);

                    await memoryPersistence.saveMemoryImageAndState(memory, savestate);

                    await kvs.put(KEY_ROM_NAME, romName);
                    await kvs.put(KEY_ROM_IMAGE, rom);
                    await kvs.put(KEY_ROM_MEMORY_SIZE, memory.length);

                    window.location.reload();
                    return true;
                }

                async function handleRom(buffer, name) {
                    await kvs.put(KEY_ROM_NAME, name);
                    await kvs.put(KEY_ROM_IMAGE, buffer);
                    await kvs.delete(KEY_ROM_MEMORY_SIZE);

                    if (memoryPersistence) {
                        memoryPersistence.stop();
                        await memoryPersistence.reset();
                    }

                    window.location.reload();
                }

                async function onImageFileSelect(e) {
                    const file = e.target.files[0];
                    if (!file || !file.name.match(/\.(rom|bin|img)$/i)) return;

                    const content = await processUpload(file);

                    if (!(file.name.match(/\.(img|bin)$/i) && await tryHandleImage(content)))
                        handleRom(content, file.name);
                }

                async function onFileUpload(e) {
                    for (const file of e.target.files) {
                        if (!file.name.match(/\.(prc|pdb)$/i)) continue;

                        const content = await processUpload(file);

                        const bufferPtr = module._malloc(content.length);
                        module.HEAP8.subarray(bufferPtr, bufferPtr + content.length).set(content);

                        module.ccall('installFile', null, ['number', 'number', 'string'], [bufferPtr, content.length, file.name]);

                        module._free(bufferPtr);
                    }
                }

                window.module = module;

                const memorySize = await (kvs.get(KEY_ROM_MEMORY_SIZE));
                if (memorySize) {
                    memoryPersistence = new MemoryPersistence(db, memorySize, module);
                }

                imageUploadButton.addEventListener('click', () => imageUpload.click());
                imageUpload.addEventListener('change', onImageFileSelect);

                fileUploadButton.addEventListener('click', () => fileUpload.click());
                fileUpload.addEventListener('change', onFileUpload);

                if (await kvs.get(KEY_ROM_NAME) && await kvs.get(KEY_ROM_IMAGE)) {
                    await launch();
                } else {
                    romName.innerText = 'No ROM image selected';
                }
            }

            // ####################################################################################
            // Bootstrap
            // ####################################################################################

            await setupDb();

            const module = await createModule({
                noInitialRun: true,
                canvas: document.getElementById('canvas'),
                print: appendLog,
                printErr: appendLog,
                sessionReady: onSessionReady,
                onCycle: () => memoryPersistence && memoryPersistence.onCycle()
            });

            main(module);
        })()
    </script>
</body>

</html>
